/**
 * Version Module for Lumiverse Helper
 *
 * This file is auto-generated by push.sh - the EXTENSION_VERSION constant
 * is updated automatically during deployment.
 *
 * Provides:
 * - Current extension version
 * - Version parsing utilities (supports semver with beta tags)
 * - SillyTavern version fetching via /version endpoint
 */

/**
 * Current extension version from manifest.json
 * Updated automatically during deployment by push.sh
 * Supports formats: "X.Y.Z" or "X.Y.Z-beta.N"
 * @type {string}
 */
export const EXTENSION_VERSION = "4.1.21";

/**
 * Parsed version object type
 * @typedef {Object} ParsedVersion
 * @property {number} major - Major version number
 * @property {number} minor - Minor/feature version number
 * @property {number} patch - Patch version number
 * @property {string|null} prerelease - Prerelease tag (e.g., "beta.1") or null
 * @property {string} raw - Original version string
 */

/**
 * Parse a semantic version string into its components
 * Supports formats: "X.Y.Z" and "X.Y.Z-prerelease.N"
 *
 * @param {string} version - Version string to parse
 * @returns {ParsedVersion|null} Parsed version object, or null if invalid
 *
 * @example
 * parseVersion("4.1.8") // { major: 4, minor: 1, patch: 8, prerelease: null, raw: "4.1.8" }
 * parseVersion("4.1.8-beta.1") // { major: 4, minor: 1, patch: 8, prerelease: "beta.1", raw: "4.1.8-beta.1" }
 */
export function parseVersion(version) {
    if (!version || typeof version !== 'string') {
        return null;
    }

    // Match semantic version with optional prerelease tag
    // Supports: X.Y.Z, X.Y.Z-beta.N, X.Y.Z-alpha.N, X.Y.Z-rc.N, etc.
    const regex = /^(\d+)\.(\d+)\.(\d+)(?:-([a-zA-Z]+(?:\.\d+)?))?$/;
    const match = version.trim().match(regex);

    if (!match) {
        return null;
    }

    return {
        major: parseInt(match[1], 10),
        minor: parseInt(match[2], 10),
        patch: parseInt(match[3], 10),
        prerelease: match[4] || null,
        raw: version.trim()
    };
}

/**
 * Format a parsed version back to a string
 *
 * @param {ParsedVersion} parsed - Parsed version object
 * @returns {string} Formatted version string
 */
export function formatVersion(parsed) {
    if (!parsed) return '';
    const base = `${parsed.major}.${parsed.minor}.${parsed.patch}`;
    return parsed.prerelease ? `${base}-${parsed.prerelease}` : base;
}

/**
 * Compare two version strings
 * Returns: -1 if a < b, 0 if a === b, 1 if a > b
 * Prerelease versions are considered less than release versions
 *
 * @param {string} a - First version string
 * @param {string} b - Second version string
 * @returns {number} Comparison result
 */
export function compareVersions(a, b) {
    const parsedA = parseVersion(a);
    const parsedB = parseVersion(b);

    if (!parsedA || !parsedB) {
        return 0;
    }

    // Compare major.minor.patch
    if (parsedA.major !== parsedB.major) {
        return parsedA.major > parsedB.major ? 1 : -1;
    }
    if (parsedA.minor !== parsedB.minor) {
        return parsedA.minor > parsedB.minor ? 1 : -1;
    }
    if (parsedA.patch !== parsedB.patch) {
        return parsedA.patch > parsedB.patch ? 1 : -1;
    }

    // Handle prerelease comparison
    // No prerelease > prerelease (e.g., 4.1.8 > 4.1.8-beta.1)
    if (!parsedA.prerelease && parsedB.prerelease) return 1;
    if (parsedA.prerelease && !parsedB.prerelease) return -1;
    if (!parsedA.prerelease && !parsedB.prerelease) return 0;

    // Both have prerelease - compare lexically
    return parsedA.prerelease.localeCompare(parsedB.prerelease);
}

/**
 * Check if a version string is a prerelease (beta, alpha, rc, etc.)
 *
 * @param {string} version - Version string to check
 * @returns {boolean} True if version is a prerelease
 */
export function isPrerelease(version) {
    const parsed = parseVersion(version);
    return parsed ? !!parsed.prerelease : false;
}

/**
 * SillyTavern version info structure
 * @typedef {Object} STVersionInfo
 * @property {string} pkgVersion - Package version from package.json
 * @property {string|null} gitBranch - Active Git branch name
 * @property {string|null} gitRevision - Short Git commit hash
 * @property {string|null} commitDate - Date of last commit
 * @property {boolean} isLatest - Whether instance is up-to-date
 * @property {string} agent - User-Agent string for API calls
 */

/**
 * Cached SillyTavern version info
 * @type {STVersionInfo|null}
 */
let cachedSTVersion = null;

/**
 * Fetch SillyTavern version information from the /version endpoint
 * Results are cached after first successful fetch
 *
 * @param {boolean} [forceRefresh=false] - Force refresh the cached version
 * @returns {Promise<STVersionInfo|null>} Version info or null on failure
 *
 * @example
 * const info = await getSillyTavernVersion();
 * console.log(info.pkgVersion); // "1.12.6"
 * console.log(info.gitBranch); // "release"
 */
export async function getSillyTavernVersion(forceRefresh = false) {
    // Return cached version if available
    if (cachedSTVersion && !forceRefresh) {
        return cachedSTVersion;
    }

    try {
        const response = await fetch('/version');

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        cachedSTVersion = data;
        return data;
    } catch (error) {
        console.error('[Lumiverse] Failed to fetch SillyTavern version:', error);
        return null;
    }
}

/**
 * Get a formatted display string for the SillyTavern version
 * Includes branch info if available
 *
 * @returns {Promise<string>} Formatted version string (e.g., "1.12.6 (release)")
 */
export async function getSTVersionDisplay() {
    const info = await getSillyTavernVersion();
    if (!info) return 'Unknown';

    if (info.gitBranch) {
        return `${info.pkgVersion} (${info.gitBranch})`;
    }
    return info.pkgVersion;
}

/**
 * Get the current Lumiverse version with prerelease indicator if applicable
 *
 * @returns {string} Formatted version (e.g., "4.1.8" or "4.1.8-beta.1")
 */
export function getLumiverseVersion() {
    return EXTENSION_VERSION;
}

/**
 * Get parsed Lumiverse version info
 *
 * @returns {ParsedVersion|null} Parsed version object
 */
export function getParsedLumiverseVersion() {
    return parseVersion(EXTENSION_VERSION);
}

/**
 * Export as default for convenience
 * @default EXTENSION_VERSION
 */
export default EXTENSION_VERSION;
